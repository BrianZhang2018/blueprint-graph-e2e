"""
Core detection engine module.

This module provides the main detection engine functionality for identifying security threats
based on graph patterns in the Neo4j database.
"""
from typing import Dict, Any, List, Optional
from src.utils import db, log
from src.schemas import ocsf_schema


class DetectionRule:
    """
    Detection rule class.
    
    This class represents a detection rule that can be applied to the graph database
    to identify security threats.
    """
    
    def __init__(
        self,
        rule_id: str,
        name: str,
        description: str,
        severity: int,
        query: str,
        tags: List[str] = None,
        mitre_techniques: List[str] = None,
        enabled: bool = True
    ):
        """
        Initialize a detection rule.
        
        Args:
            rule_id (str): Unique identifier for the rule
            name (str): Human-readable name for the rule
            description (str): Description of what the rule detects
            severity (int): Severity level (1-10)
            query (str): Cypher query to execute for detection
            tags (list, optional): List of tags for categorization
            mitre_techniques (list, optional): List of MITRE ATT&CK techniques
            enabled (bool, optional): Whether the rule is enabled
        """
        self.rule_id = rule_id
        self.name = name
        self.description = description
        self.severity = severity
        self.query = query
        self.tags = tags or []
        self.mitre_techniques = mitre_techniques or []
        self.enabled = enabled
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the rule to a dictionary.
        
        Returns:
            dict: Dictionary representation of the rule
        """
        return {
            "rule_id": self.rule_id,
            "name": self.name,
            "description": self.description,
            "severity": self.severity,
            "query": self.query,
            "tags": self.tags,
            "mitre_techniques": self.mitre_techniques,
            "enabled": self.enabled
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'DetectionRule':
        """
        Create a rule from a dictionary.
        
        Args:
            data (dict): Dictionary representation of the rule
            
        Returns:
            DetectionRule: New detection rule instance
        """
        return cls(
            rule_id=data["rule_id"],
            name=data["name"],
            description=data["description"],
            severity=data["severity"],
            query=data["query"],
            tags=data.get("tags", []),
            mitre_techniques=data.get("mitre_techniques", []),
            enabled=data.get("enabled", True)
        )


class DetectionAlert:
    """
    Detection alert class.
    
    This class represents an alert generated by the detection engine when a rule matches.
    """
    
    def __init__(
        self,
        alert_id: str,
        rule_id: str,
        timestamp: str,
        severity: int,
        entities: List[Dict[str, Any]],
        context: Dict[str, Any] = None
    ):
        """
        Initialize a detection alert.
        
        Args:
            alert_id (str): Unique identifier for the alert
            rule_id (str): ID of the rule that generated the alert
            timestamp (str): Timestamp when the alert was generated
            severity (int): Severity level (1-10)
            entities (list): List of entities involved in the alert
            context (dict, optional): Additional context information
        """
        self.alert_id = alert_id
        self.rule_id = rule_id
        self.timestamp = timestamp
        self.severity = severity
        self.entities = entities
        self.context = context or {}
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the alert to a dictionary.
        
        Returns:
            dict: Dictionary representation of the alert
        """
        return {
            "alert_id": self.alert_id,
            "rule_id": self.rule_id,
            "timestamp": self.timestamp,
            "severity": self.severity,
            "entities": self.entities,
            "context": self.context
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'DetectionAlert':
        """
        Create an alert from a dictionary.
        
        Args:
            data (dict): Dictionary representation of the alert
            
        Returns:
            DetectionAlert: New detection alert instance
        """
        return cls(
            alert_id=data["alert_id"],
            rule_id=data["rule_id"],
            timestamp=data["timestamp"],
            severity=data["severity"],
            entities=data["entities"],
            context=data.get("context", {})
        )


class DetectionEngine:
    """
    Detection engine class.
    
    This class provides methods for loading rules, running detections, and generating alerts.
    """
    
    def __init__(self):
        """Initialize the detection engine."""
        self.rules = {}
    
    def load_rule(self, rule: DetectionRule) -> None:
        """
        Load a detection rule.
        
        Args:
            rule (DetectionRule): The rule to load
        """
        self.rules[rule.rule_id] = rule
        log.info(f"Loaded detection rule: {rule.name} ({rule.rule_id})")
    
    def load_rules_from_file(self, file_path: str) -> None:
        """
        Load detection rules from a JSON file.
        
        Args:
            file_path (str): Path to the JSON file containing rules
        """
        import json
        import os
        
        if not os.path.exists(file_path):
            log.error(f"Rules file not found: {file_path}")
            return
        
        try:
            with open(file_path, 'r') as f:
                rules_data = json.load(f)
            
            # Clear existing rules if loading from a file
            self.rules = {}
            
            # Load each rule
            for rule_data in rules_data:
                rule = DetectionRule.from_dict(rule_data)
                self.load_rule(rule)
            
            log.info(f"Loaded {len(rules_data)} rules from {file_path}")
        except Exception as e:
            log.error(f"Failed to load rules from {file_path}: {str(e)}")
    
    def run_detection(self, rule_id: Optional[str] = None) -> List[DetectionAlert]:
        """
        Run detection using the specified rule or all rules.
        
        Args:
            rule_id (str, optional): ID of the rule to run, or None to run all rules
            
        Returns:
            list: List of detection alerts
        """
        alerts = []
        
        if rule_id:
            if rule_id not in self.rules:
                log.error(f"Rule not found: {rule_id}")
                return []
            
            rule = self.rules[rule_id]
            if not rule.enabled:
                log.warning(f"Rule is disabled: {rule_id}")
                return []
            
            alerts.extend(self._run_rule(rule))
        else:
            for rule in self.rules.values():
                if rule.enabled:
                    alerts.extend(self._run_rule(rule))
        
        return alerts
    
    def _run_rule(self, rule: DetectionRule) -> List[DetectionAlert]:
        """
        Run a single detection rule.
        
        Args:
            rule (DetectionRule): The rule to run
            
        Returns:
            list: List of detection alerts
        """
        import uuid
        from datetime import datetime
        
        alerts = []
        
        try:
            # Execute the rule's Cypher query
            results = db.execute_query(rule.query)
            
            if not results:
                return []
            
            # Generate alerts for each result
            for result in results:
                alert_id = str(uuid.uuid4())
                timestamp = datetime.utcnow().isoformat() + 'Z'
                
                # Extract entities from the result
                entities = []
                for key, value in result.items():
                    # Skip non-entity fields like counts or aggregates
                    if isinstance(value, (int, float, str, bool)) or value is None:
                        continue
                        
                    # Handle Neo4j node objects
                    if hasattr(value, 'labels') and hasattr(value, 'id') and hasattr(value, 'items'):
                        # This is a Neo4j node
                        entity_type = next(iter(value.labels), 'Unknown')
                        entity_id = value.get('id', str(value.id))
                        
                        # Convert node properties to a dictionary
                        properties = {}
                        for k, v in value.items():
                            properties[k] = v
                        
                        entities.append({
                            "type": entity_type,
                            "id": entity_id,
                            "properties": properties
                        })
                    # Handle dictionary-like objects that might represent nodes
                    elif isinstance(value, dict) and 'id' in value:
                        entity_type = key.capitalize()  # Use the key as the entity type
                        entity_id = value.get('id')
                        
                        entities.append({
                            "type": entity_type,
                            "id": entity_id,
                            "properties": value
                        })
                
                # If no entities were extracted but we have results, create a generic entity
                if not entities and result:
                    # Use the first key as the entity type
                    first_key = next(iter(result.keys()))
                    entities.append({
                        "type": first_key.capitalize(),
                        "id": str(uuid.uuid4()),
                        "properties": {k: str(v) for k, v in result.items()}
                    })
                
                alert = DetectionAlert(
                    alert_id=alert_id,
                    rule_id=rule.rule_id,
                    timestamp=timestamp,
                    severity=rule.severity,
                    entities=entities,
                    context={"raw_result": {k: str(v) for k, v in result.items()}}  # Convert to string to ensure serializable
                )
                
                alerts.append(alert)
                log.info(f"Generated alert {alert_id} from rule {rule.rule_id}")
        
        except Exception as e:
            log.error(f"Error running rule {rule.rule_id}: {str(e)}")
        
        return alerts
    
    def store_alert(self, alert: DetectionAlert) -> bool:
        """
        Store an alert in the database.
        
        Args:
            alert (DetectionAlert): The alert to store
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Create an Alert node in Neo4j
            query = """
            CREATE (a:Alert {
                alert_id: $alert_id,
                rule_id: $rule_id,
                timestamp: $timestamp,
                severity: $severity
            })
            RETURN a
            """
            
            params = {
                "alert_id": alert.alert_id,
                "rule_id": alert.rule_id,
                "timestamp": alert.timestamp,
                "severity": alert.severity
            }
            
            result = db.execute_query(query, params)
            
            if not result:
                log.error(f"Failed to create Alert node for {alert.alert_id}")
                return False
            
            # For each entity in the alert, create a relationship to the Alert node
            for entity in alert.entities:
                entity_type = entity.get("type", "Unknown")
                entity_id = entity.get("id", "unknown")
                
                # First check if the entity exists
                check_query = f"""
                MATCH (e:{entity_type} {{id: $entity_id}})
                RETURN e
                """
                
                check_params = {
                    "entity_id": entity_id
                }
                
                entity_exists = db.execute_query(check_query, check_params)
                
                if entity_exists:
                    # Create relationship if entity exists
                    entity_query = f"""
                    MATCH (a:Alert {{alert_id: $alert_id}})
                    MATCH (e:{entity_type} {{id: $entity_id}})
                    CREATE (a)-[:INVOLVES]->(e)
                    RETURN a, e
                    """
                    
                    entity_params = {
                        "alert_id": alert.alert_id,
                        "entity_id": entity_id
                    }
                    
                    db.execute_query(entity_query, entity_params)
                else:
                    # Create the entity if it doesn't exist
                    properties = entity.get("properties", {})
                    properties_str = ", ".join([f"{k}: ${k}" for k in properties.keys()])
                    
                    create_query = f"""
                    MATCH (a:Alert {{alert_id: $alert_id}})
                    CREATE (e:{entity_type} {{id: $entity_id, {properties_str}}})
                    CREATE (a)-[:INVOLVES]->(e)
                    RETURN a, e
                    """
                    
                    create_params = {
                        "alert_id": alert.alert_id,
                        "entity_id": entity_id,
                        **properties
                    }
                    
                    db.execute_query(create_query, create_params)
            
            log.info(f"Stored alert {alert.alert_id} in the database")
            return True
        
        except Exception as e:
            log.error(f"Failed to store alert {alert.alert_id}: {str(e)}")
            return False


# Create a global detection engine instance
detection_engine = DetectionEngine() 